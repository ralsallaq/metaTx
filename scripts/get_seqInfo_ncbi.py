#!/usr/bin/env python 
""" 
This module demultiplex the sequence file generated by decard to separate fasta files speciesd by SAMPLENAME_R1_ID.fasta
"""
from __future__ import print_function
import argparse
from Bio import SeqIO, Entrez, pairwise2
from Bio.SeqRecord import SeqRecord
from Bio.SeqIO.FastaIO import SimpleFastaParser
from Bio.Seq import Seq
import re
import os, sys, time
import pandas as pd
import numpy as np
from Bio import Entrez
import tempfile
from shutil import copy2
######################################################################


p_desc=re.compile(r"""
(description)   #the keys group
(=")  #the values starter
([^"]+) #the values: everything without the = sign even one time
(")  #the values terminator
""", re.VERBOSE)


p_taxa=re.compile(r"""
(taxonomy)   #the keys group
(=")  #the values starter
([^"]+) #the values: everything without the = sign even one time
(")  #the values terminator
""", re.VERBOSE)

p_organism=re.compile(r"""
(organism)   #the keys group
(=")  #the values starter
([^"]+) #the values
(")  #the values terminator
""", re.VERBOSE)

p_taxid=re.compile("""
        (ncbi_tax_id)
        (=")
        (.*)
        (")
""", re.VERBOSE)

#######Functions to fetch taxonomy from NCBI db #############
Entrez.email = "ralsalla@stjude.org"
if not Entrez.email:
    print ("you must add your email address")
    sys.exit(2)

def Entrez_NCBI():
    """ This function displays all searchable fields available in Entrez"""
    data = Entrez.read(Entrez.einfo(db="taxonomy"))
    for field in data["DbInfo"]["FieldList"]:
        print("%(Name)s, %(FullName)s,%(Description)s" % field)

def get_taxid(species):
    """to get data from ncbi taxomomy, we need to have the taxid.  we can
    get that by passing the species name to esearch, which will return
    the tax id"""
    species = species.replace(" ", "+").strip()
    search = Entrez.esearch(term = species, db = "taxonomy", retmode = "xml")
    record = Entrez.read(search)
    return record['IdList'][0]

def get_tax_data(taxid):
    """once we have the taxid, we can fetch the record"""
    search = Entrez.efetch(id = taxid, db = "taxonomy", retmode = "xml")
    return Entrez.read(search)

def get_lineage(data):
    """once you have the data from get_tax_data fetch the lineage"""
    uprank=['kingdom','phylum','class','order','family','genus']
    lineage = {d['Rank']:d['ScientificName'] for d in data[0]['LineageEx'] if d['Rank'] in uprank}
    try: 
        lineage['kingdom']
    except KeyError:
        dict_ = {d['Rank']:d['ScientificName'] for d in data[0]['LineageEx'] if d['Rank']=="superkingdom"}
        dict_['kingdom']=dict_.pop('superkingdom')
        lineage.update(dict_)
    return lineage


def main():
    """fixes taxids to primary taxids and saves a seqInfo file"""
    args_parser = argparse.ArgumentParser()
    args_parser.add_argument('--input_fasta','-i', help='fasta file with ncbi format titles and unchecked taxids', required=True)
    args_parser.add_argument('--yourEmail','-e', help='a valid email for NCBI server inquiries', required=True)
    args_parser.add_argument('--out_seqInfo','-oC', help='csv file with seqname, tax_id, species_name titles', required=True)
    args_parser.add_argument('--out_fasta','-oF', help='fasta file with ncbi format titles and primary taxids', required=True)
    args = args_parser.parse_args()

    # First handle the files
    input_fasta = args.input_fasta
    output_fasta = args.out_fasta
    output_file = args.out_seqInfo

    with open(output_fasta,'wt') as out_hdl:
        with open(input_fasta,'rt') as inp_hdl:
            seqname=[]
            tax_id=[]
            species_name=[]
            seqLen=[]
            description=[]
            lineage=[]
            nomatch_taxid=[]
            nomatch_organism=[]
            nomatch_primtaxid=[]
            df_seqInfo=pd.DataFrame()
            df_nomatch=pd.DataFrame()
            for title, sequence in SimpleFastaParser(inp_hdl):
                Len =  len(str(sequence)) 
                print(Len)
                full_ttl=title
                ttl=title.split(None,1)[0]
                desc=title.split(None,1)[1]
                #print(full_ttl,"\n", ttl,"\n", desc)
                print(p_organism.findall(desc))
                try:
                    taxid=p_taxid.findall(desc)[0][2]
                    name = ttl.split(";")[0].replace(".","_")
                    organism= p_organism.findall(desc)[0][2].replace("=","").replace("-","_").replace("[","").replace("]","").replace(".","_")
                    taxonomy=p_taxa.findall(desc)[0][2]
                    #details=p_desc.findall(desc)[0][2]
                    details="" #for rdp set
    
                    recordFitched = False
                    while not recordFitched:
                        try:
                            data=get_tax_data(str(taxid))
                            #print(data[0]['TaxId'])
                            primary_taxid=data[0]['TaxId']
                            print(primary_taxid, taxid)
                            recordFitched = True
                        except:
                            time.sleep(8)
                            recordFitched = False
                    if taxid.strip() != primary_taxid.strip():
                        print("record ",name, " has a primary taxid different than the database")
                        #save for nomatch
                        nomatch_organism.append(organism)
                        nomatch_taxid.append(taxid.strip())
                        nomatch_primtaxid.append(primary_taxid.strip())
                        #replace taxid in title with primary taxid 
                        full_ttl=full_ttl.replace('ncbi_tax_id='+'"'+taxid.strip()+'"', 'ncbi_tax_id='+'"'+primary_taxid.strip()+'"')
                        #replace taxid with primary taxid 
                        taxid = primary_taxid
                except:
                    taxid=""
                    name = ttl.split(";")[0]
                    print("except",name, desc)
                    organism=""
                    taxonomy=""
                    details=""
                out_hdl.write(">%s\n%s\n" % (full_ttl, sequence))
                seqname.append(name)
                tax_id.append(taxid)
                species_name.append(organism)
                seqLen.append(Len)
                lineage.append(taxonomy)
                description.append(details)
    
            df_seqInfo.loc[:,'seqname']=seqname
            df_seqInfo.loc[:,'tax_id']=tax_id
            df_seqInfo.loc[:,'species_name']=species_name
            df_seqInfo.loc[:,'seqLength']=seqLen
            df_seqInfo.loc[:,'description']=description
            df_seqInfo.loc[:,'taxonomy']=lineage
            if(df_seqInfo['seqname'].notnull().sum() != df_seqInfo['tax_id'].notnull().sum()):
                print("not all sequences have taxids, check parsing in the script")
            df_seqInfo.to_csv(output_file, index=False)
            #save tax_id,species_name,primary_tax_id for nonmatching taxids
            if len(nomatch_taxid)>0:
                print("There are some taxids that are different from primary taxids and a csv will be saved under the name nomatchedTaxIDs.csv")
                df_nomatch.loc[:,'tax_id']=nomatch_taxid
                df_nomatch.loc[:,'species_name']=nomatch_organism
                df_nomatch.loc[:,'primary_tax_id']=nomatch_primtaxid
                df_nomatch.to_csv("nomatchedTaxIDs.csv", index=False)
            else:
                print("All taxids are matching primary values")

    print("csv and fasta files with primary taxids are successfully saved")


    #savefasta(df_merge, no_qc_outf)

if __name__ == "__main__":
    main()
